import { Checksum160, Bytes, APIClient, FetchProvider, Struct, Action, Transaction, PermissionLevel, Checksum256, PrivateKey } from '@wharfkit/antelope';
import fetch, { Response } from 'node-fetch';
import { join } from 'path';
import { promisify } from 'util';
import { readFile as readFile$1, writeFile as writeFile$1 } from 'fs';
import { AbstractWalletPlugin, WalletPluginMetadata, ChainDefinition, SigningRequest, AbstractUserInterface, Checksum256 as Checksum256$1, PermissionLevel as PermissionLevel$1, cancelable, SessionKit, Session, ABICache, TransactContext, AbstractTransactPlugin, TransactHookTypes, Struct as Struct$1, Action as Action$1, prependAction } from '@wharfkit/session';
import { WalletPluginPrivateKey } from '@wharfkit/wallet-plugin-privatekey';
import { __decorate } from 'tslib';

const mockChainId = '73e4385a2708e6d7048834fbc1079f2fabb17b3c125b146af438971e90716c4d';
const mockUrl = 'https://jungle4.greymass.com';
const mockChainDefinition = {
    id: mockChainId,
    url: mockUrl,
};
const mockChainDefinitions = [
    mockChainDefinition,
    {
        id: 'aca376f206b8fc25a6ed44dbdc66547c36c6c33e3a119ffbeaef943642f0e906',
        url: 'https://eos.greymass.com',
    },
    {
        id: '4667b205c6838ef70ff7988f6e8257e8be0e1284a2f59699054a018f743b1d11',
        url: 'https://telos.greymass.com',
    },
    {
        id: '1064487b3cd1a897ce03ae5b6a865651747e2e152090f99c1d19d44e01aea5a4',
        url: 'https://wax.greymass.com',
    },
    {
        id: '34593b65376aee3c9b06ea8a8595122b39333aaab4c76ad52587831fcc096590',
        url: 'https://mockuserinterface.greymass.com',
    },
];
const mockPrivateKey = '5Jtoxgny5tT7NiNFp1MLogviuPJ9NniWjnU4wKzaX4t7pL4kJ8s';
const mockAccountName = 'wharfkit1111';
const mockPermissionName = 'test';
const mockPermissionLevel = `${mockAccountName}@${mockPermissionName}`;

const readFile = promisify(readFile$1);
const writeFile = promisify(writeFile$1);
function getFilename(path, params) {
    const digest = Checksum160.hash(Bytes.from(path + (params ? JSON.stringify(params) : ''), 'utf8')).hexString;
    if (!process.env['MOCK_DIR']) {
        throw new Error('MOCK_DIR environment variable not set');
    }
    return join(__dirname, '../../../../', process.env['MOCK_DIR'], digest + '.json');
}
async function getExisting(filename) {
    try {
        const data = await readFile(filename);
        return JSON.parse(data.toString('utf8'));
    }
    catch (error) {
        if (error.code !== 'ENOENT') {
            throw error;
        }
    }
}
async function mockFetch(path, params) {
    if (process.env['LOGHTTP']) {
        console.log('HTTP Request', { path, params });
    }
    const filename = getFilename(path, params);
    if (process.env['MOCK'] !== 'overwrite') {
        const existing = await getExisting(filename);
        if (existing) {
            if (process.env['LOGHTTP'] === 'size') {
                const size = Buffer.byteLength(JSON.stringify(existing.json));
                console.log('HTTP Response (from API)', { path, params, size });
            }
            return new Response(existing.text, {
                status: existing.status,
                headers: existing.headers,
            });
        }
    }
    if (process.env['MOCK']) {
        const response = await fetch(path, params);
        const cloned = await response.clone();
        let size = 0;
        cloned.json().then((json) => {
            size = Buffer.byteLength(JSON.stringify(json));
            writeFile(filename, JSON.stringify({
                request: {
                    path,
                    params,
                },
                status: response.status,
                json,
                text: JSON.stringify(json),
            }, undefined, 4));
            if (process.env['LOGHTTP'] === 'size') {
                console.log('HTTP Response (from API)', { path, params, size });
            }
        });
        return response;
    }
    else {
        throw new Error(`No data for ${path}`);
    }
}

function makeClient(url) {
    return new APIClient({
        provider: new FetchProvider(url || mockUrl, { fetch: mockFetch }),
    });
}

let Transfer = class Transfer extends Struct {
};
__decorate([
    Struct.field('name')
], Transfer.prototype, "from", void 0);
__decorate([
    Struct.field('name')
], Transfer.prototype, "to", void 0);
__decorate([
    Struct.field('asset')
], Transfer.prototype, "quantity", void 0);
__decorate([
    Struct.field('string')
], Transfer.prototype, "memo", void 0);
Transfer = __decorate([
    Struct.type('transfer')
], Transfer);
function makeMockAction(memo) {
    const transfer = Transfer.from({
        from: mockAccountName,
        to: 'teamgreymass',
        quantity: '0.1337 EOS',
        memo: memo || 'wharfkit is the best <3',
    });
    const action = Action.from({
        authorization: [
            {
                actor: mockAccountName,
                permission: mockPermissionName,
            },
        ],
        account: 'eosio.token',
        name: 'transfer',
        data: transfer,
    });
    return action;
}
function makeMockActions(memo) {
    return [makeMockAction(memo)];
}
function makeMockTransaction(info, memo) {
    const header = info.getTransactionHeader(90);
    const actions = makeMockActions(memo);
    const transaction = Transaction.from({
        ...header,
        actions,
    });
    return transaction;
}

function makeWallet() {
    return new WalletPluginPrivateKey(mockPrivateKey);
}
class MockWalletPluginConfigs extends AbstractWalletPlugin {
    constructor(config, initialData = {}) {
        super();
        this.metadata = WalletPluginMetadata.from({
            name: 'Mock Wallet Plugin',
            description: 'A mock wallet plugin for testing chain selection',
            logo: 'https://assets.wharfkit.com/chain/jungle.png',
        });
        this.testModify = false;
        if (config) {
            this.config = config;
        }
        else {
            this.config = {
                requiresChainSelect: true,
                requiresPermissionSelect: false,
            };
        }
        this.data = initialData;
    }
    get id() {
        return 'MockWalletPluginConfigs';
    }
    async login(context) {
        return {
            chain: context.chain ? context.chain.id : ChainDefinition.from(mockChainDefinition).id,
            permissionLevel: context.permissionLevel || PermissionLevel.from(mockPermissionLevel),
        };
    }
    async sign(resolved, context) {
        if (context.storage) {
            context.storage.write('testModify', this.data.testModify);
        }
        if (this.data.testModify) {
            const request = await SigningRequest.create({ action: makeMockAction('modified transaction') }, context.esrOptions);
            const resolved = await context.resolve(request);
            const transaction = Transaction.from(resolved.transaction);
            const digest = transaction.signingDigest(Checksum256.from(context.chain.id));
            const privateKey = PrivateKey.from(this.data.privateKey);
            const signature = privateKey.signDigest(digest);
            return {
                resolved: resolved,
                signatures: [signature],
            };
        }
        const transaction = Transaction.from(resolved.transaction);
        const digest = transaction.signingDigest(Checksum256.from(context.chain.id));
        const privateKey = PrivateKey.from(this.data.privateKey);
        const signature = privateKey.signDigest(digest);
        return {
            signatures: [signature],
        };
    }
}

class MockStorage {
    constructor() {
        this.data = {};
    }
    async write(key, data) {
        this.data[key] = data;
    }
    async read(key) {
        return this.data[key];
    }
    async remove(key) {
        delete this.data[key];
    }
    storageKey(key) {
        return `mock-${key}`;
    }
}

class MockUserInterface extends AbstractUserInterface {
    constructor() {
        super(...arguments);
        this.logging = false;
        this.messages = [];
        this.localeDefinitions = {};
    }
    log(message) {
        this.messages.push(message);
        if (this.logging) {
            console.info('MockUserInterface', message);
        }
    }
    async login(context) {
        let chainId = context.chain?.id;
        if (!chainId) {
            chainId = Checksum256$1.from(context.chains[0].id);
        }
        let permissionLevel = context.permissionLevel;
        if (!permissionLevel) {
            permissionLevel = PermissionLevel$1.from('mock@interface');
        }
        return {
            chainId,
            permissionLevel,
            walletPluginIndex: 0,
        };
    }
    async onError(error) {
        this.log('onError: ' + JSON.stringify(error));
    }
    async onLogin(options) {
        this.log('onLogin: ' + JSON.stringify(options));
    }
    async onLoginComplete() {
        this.log('onLoginComplete');
    }
    async onTransact() {
        this.log('onTransact');
    }
    async onTransactComplete() {
        this.log('onTransactComplete');
    }
    async onSign() {
        this.log('onSign');
    }
    async onSignComplete() {
        this.log('onSignComplete');
    }
    async onBroadcast() {
        this.log('onBroadcast');
    }
    async onBroadcastComplete() {
        this.log('onBroadcastComplete');
    }
    prompt(args) {
        this.log('prompt' + JSON.stringify(args));
        return cancelable(new Promise(() => {
        }), (canceled) => {
            throw canceled;
        });
    }
    status(message) {
        this.log(`status:('${message}')`);
    }
    addTranslations(definitions) {
        this.log('addTranslations: ' + JSON.stringify(definitions));
    }
    async onAccountCreate() {
        this.log('onAccountCreate');
        return Promise.resolve({});
    }
    async onAccountCreateComplete() {
        this.log('onAccountCreateComplete');
    }
}

const wallet = makeWallet();
const mockSessionKitArgs = {
    appName: 'unittest',
    chains: mockChainDefinitions,
    ui: new MockUserInterface(),
    walletPlugins: [wallet],
};
const mockSessionKitOptions = {
    fetch: mockFetch,
    storage: new MockStorage(),
};
const mockSessionKit = new SessionKit(mockSessionKitArgs, mockSessionKitOptions);
const mockSessionArgs = {
    chain: mockChainDefinition,
    permissionLevel: PermissionLevel.from(mockPermissionLevel),
    walletPlugin: wallet,
};
const mockSessionOptions = {
    broadcast: false,
    fetch: mockFetch,
};
const mockSession = new Session(mockSessionArgs, mockSessionOptions);

const client$1 = new APIClient({
    provider: new FetchProvider(mockUrl, { fetch: mockFetch }),
});
const session = new Session(mockSessionArgs, mockSessionOptions);
const abiCache = new ABICache(client$1);
const mockTransactContextOptions = {
    abiCache,
    chain: ChainDefinition.from(mockChainDefinition),
    client: client$1,
    createRequest: async (args) => session.createRequest(args, abiCache),
    fetch: mockFetch,
    permissionLevel: PermissionLevel.from('wharfkit1125@test'),
};
function makeContext() {
    return new TransactContext(mockTransactContextOptions);
}

const client = makeClient();
async function mockData(memo) {
    const info = await client.v1.chain.get_info();
    const action = await makeMockAction(memo);
    const actions = await makeMockActions(memo);
    const transaction = await makeMockTransaction(info, memo);
    const session = new Session(mockSessionArgs, mockSessionOptions);
    return {
        action,
        actions,
        info,
        session,
        transaction,
    };
}

async function mockLoginHook() {
}
async function mockTransactHook(request) {
    return {
        request,
        signatures: [],
    };
}
class MockTransactPlugin extends AbstractTransactPlugin {
    constructor() {
        super(...arguments);
        this.id = 'mock-transact-plugin';
    }
    register(context) {
        context.addHook(TransactHookTypes.beforeSign, mockTransactHook);
        context.addHook(TransactHookTypes.afterSign, mockTransactHook);
        context.addHook(TransactHookTypes.afterBroadcast, mockTransactHook);
    }
}
class noop extends Struct$1 {
}
noop.abiName = 'noop';
noop.abiFields = [];
async function mockTransactResourceProviderPresignHook(request, context) {
    const options = context.transactPluginsOptions;
    if (options.disableExamplePlugin) {
        return {
            request,
            signatures: [],
        };
    }
    const newAction = Action$1.from({
        account: 'greymassnoop',
        name: 'noop',
        authorization: [
            {
                actor: 'greymassfuel',
                permission: 'cosign',
            },
        ],
        data: noop.from({}),
    });
    const modified = prependAction(request, newAction);
    return {
        request: modified,
        signatures: [],
    };
}
class MockTransactResourceProviderPlugin extends AbstractTransactPlugin {
    constructor() {
        super(...arguments);
        this.id = 'mock-transact-resource-provider-plugin';
    }
    register(context) {
        context.addHook(TransactHookTypes.beforeSign, mockTransactResourceProviderPresignHook);
    }
}
const mockTransactActionPrependerPlugin = {
    id: 'mock-transact-action-prepender-plugin',
    register: (context) => context.addHook(TransactHookTypes.beforeSign, async (request, context) => ({
        request: await SigningRequest.create({
            actions: [
                {
                    account: 'greymassnoop',
                    name: 'noop',
                    authorization: [
                        {
                            actor: [...Array(12)]
                                .map(() => Math.random().toString(36)[2])
                                .join(''),
                            permission: 'test',
                        },
                    ],
                    data: {},
                },
                ...request.getRawActions(),
            ],
        }, context.esrOptions),
    })),
};
const mockMetadataFooWriterPlugin = {
    id: 'mock-metadata-foo-writer-plugin',
    register: (context) => context.addHook(TransactHookTypes.beforeSign, async (request) => {
        request.setInfoKey('foo', 'baz');
        return {
            request,
        };
    }),
};

export { MockStorage, MockTransactPlugin, MockTransactResourceProviderPlugin, MockUserInterface, MockWalletPluginConfigs, makeClient, makeContext, makeMockAction, makeMockActions, makeMockTransaction, makeWallet, mockAccountName, mockChainDefinition, mockChainDefinitions, mockChainId, mockData, mockFetch, mockLoginHook, mockMetadataFooWriterPlugin, mockPermissionLevel, mockPermissionName, mockPrivateKey, mockSession, mockSessionArgs, mockSessionKit, mockSessionKitArgs, mockSessionKitOptions, mockSessionOptions, mockTransactActionPrependerPlugin, mockTransactContextOptions, mockTransactHook, mockTransactResourceProviderPresignHook, mockUrl };
//# sourceMappingURL=mock-data.m.js.map
