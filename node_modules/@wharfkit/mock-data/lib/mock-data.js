'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var antelope = require('@wharfkit/antelope');
var fetch = require('node-fetch');
var path = require('path');
var util = require('util');
var fs = require('fs');
var session$1 = require('@wharfkit/session');
var walletPluginPrivatekey = require('@wharfkit/wallet-plugin-privatekey');
var tslib = require('tslib');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var fetch__default = /*#__PURE__*/_interopDefaultLegacy(fetch);

const mockChainId = '73e4385a2708e6d7048834fbc1079f2fabb17b3c125b146af438971e90716c4d';
const mockUrl = 'https://jungle4.greymass.com';
const mockChainDefinition = {
    id: mockChainId,
    url: mockUrl,
};
const mockChainDefinitions = [
    mockChainDefinition,
    {
        id: 'aca376f206b8fc25a6ed44dbdc66547c36c6c33e3a119ffbeaef943642f0e906',
        url: 'https://eos.greymass.com',
    },
    {
        id: '4667b205c6838ef70ff7988f6e8257e8be0e1284a2f59699054a018f743b1d11',
        url: 'https://telos.greymass.com',
    },
    {
        id: '1064487b3cd1a897ce03ae5b6a865651747e2e152090f99c1d19d44e01aea5a4',
        url: 'https://wax.greymass.com',
    },
    {
        id: '34593b65376aee3c9b06ea8a8595122b39333aaab4c76ad52587831fcc096590',
        url: 'https://mockuserinterface.greymass.com',
    },
];
const mockPrivateKey = '5Jtoxgny5tT7NiNFp1MLogviuPJ9NniWjnU4wKzaX4t7pL4kJ8s';
const mockAccountName = 'wharfkit1111';
const mockPermissionName = 'test';
const mockPermissionLevel = `${mockAccountName}@${mockPermissionName}`;

const readFile = util.promisify(fs.readFile);
const writeFile = util.promisify(fs.writeFile);
function getFilename(path$1, params) {
    const digest = antelope.Checksum160.hash(antelope.Bytes.from(path$1 + (params ? JSON.stringify(params) : ''), 'utf8')).hexString;
    if (!process.env['MOCK_DIR']) {
        throw new Error('MOCK_DIR environment variable not set');
    }
    return path.join(__dirname, '../../../../', process.env['MOCK_DIR'], digest + '.json');
}
async function getExisting(filename) {
    try {
        const data = await readFile(filename);
        return JSON.parse(data.toString('utf8'));
    }
    catch (error) {
        if (error.code !== 'ENOENT') {
            throw error;
        }
    }
}
async function mockFetch(path, params) {
    if (process.env['LOGHTTP']) {
        console.log('HTTP Request', { path, params });
    }
    const filename = getFilename(path, params);
    if (process.env['MOCK'] !== 'overwrite') {
        const existing = await getExisting(filename);
        if (existing) {
            if (process.env['LOGHTTP'] === 'size') {
                const size = Buffer.byteLength(JSON.stringify(existing.json));
                console.log('HTTP Response (from API)', { path, params, size });
            }
            return new fetch.Response(existing.text, {
                status: existing.status,
                headers: existing.headers,
            });
        }
    }
    if (process.env['MOCK']) {
        const response = await fetch__default["default"](path, params);
        const cloned = await response.clone();
        let size = 0;
        cloned.json().then((json) => {
            size = Buffer.byteLength(JSON.stringify(json));
            writeFile(filename, JSON.stringify({
                request: {
                    path,
                    params,
                },
                status: response.status,
                json,
                text: JSON.stringify(json),
            }, undefined, 4));
            if (process.env['LOGHTTP'] === 'size') {
                console.log('HTTP Response (from API)', { path, params, size });
            }
        });
        return response;
    }
    else {
        throw new Error(`No data for ${path}`);
    }
}

function makeClient(url) {
    return new antelope.APIClient({
        provider: new antelope.FetchProvider(url || mockUrl, { fetch: mockFetch }),
    });
}

let Transfer = class Transfer extends antelope.Struct {
};
tslib.__decorate([
    antelope.Struct.field('name')
], Transfer.prototype, "from", void 0);
tslib.__decorate([
    antelope.Struct.field('name')
], Transfer.prototype, "to", void 0);
tslib.__decorate([
    antelope.Struct.field('asset')
], Transfer.prototype, "quantity", void 0);
tslib.__decorate([
    antelope.Struct.field('string')
], Transfer.prototype, "memo", void 0);
Transfer = tslib.__decorate([
    antelope.Struct.type('transfer')
], Transfer);
function makeMockAction(memo) {
    const transfer = Transfer.from({
        from: mockAccountName,
        to: 'teamgreymass',
        quantity: '0.1337 EOS',
        memo: memo || 'wharfkit is the best <3',
    });
    const action = antelope.Action.from({
        authorization: [
            {
                actor: mockAccountName,
                permission: mockPermissionName,
            },
        ],
        account: 'eosio.token',
        name: 'transfer',
        data: transfer,
    });
    return action;
}
function makeMockActions(memo) {
    return [makeMockAction(memo)];
}
function makeMockTransaction(info, memo) {
    const header = info.getTransactionHeader(90);
    const actions = makeMockActions(memo);
    const transaction = antelope.Transaction.from({
        ...header,
        actions,
    });
    return transaction;
}

function makeWallet() {
    return new walletPluginPrivatekey.WalletPluginPrivateKey(mockPrivateKey);
}
class MockWalletPluginConfigs extends session$1.AbstractWalletPlugin {
    constructor(config, initialData = {}) {
        super();
        this.metadata = session$1.WalletPluginMetadata.from({
            name: 'Mock Wallet Plugin',
            description: 'A mock wallet plugin for testing chain selection',
            logo: 'https://assets.wharfkit.com/chain/jungle.png',
        });
        this.testModify = false;
        if (config) {
            this.config = config;
        }
        else {
            this.config = {
                requiresChainSelect: true,
                requiresPermissionSelect: false,
            };
        }
        this.data = initialData;
    }
    get id() {
        return 'MockWalletPluginConfigs';
    }
    async login(context) {
        return {
            chain: context.chain ? context.chain.id : session$1.ChainDefinition.from(mockChainDefinition).id,
            permissionLevel: context.permissionLevel || antelope.PermissionLevel.from(mockPermissionLevel),
        };
    }
    async sign(resolved, context) {
        if (context.storage) {
            context.storage.write('testModify', this.data.testModify);
        }
        if (this.data.testModify) {
            const request = await session$1.SigningRequest.create({ action: makeMockAction('modified transaction') }, context.esrOptions);
            const resolved = await context.resolve(request);
            const transaction = antelope.Transaction.from(resolved.transaction);
            const digest = transaction.signingDigest(antelope.Checksum256.from(context.chain.id));
            const privateKey = antelope.PrivateKey.from(this.data.privateKey);
            const signature = privateKey.signDigest(digest);
            return {
                resolved: resolved,
                signatures: [signature],
            };
        }
        const transaction = antelope.Transaction.from(resolved.transaction);
        const digest = transaction.signingDigest(antelope.Checksum256.from(context.chain.id));
        const privateKey = antelope.PrivateKey.from(this.data.privateKey);
        const signature = privateKey.signDigest(digest);
        return {
            signatures: [signature],
        };
    }
}

class MockStorage {
    constructor() {
        this.data = {};
    }
    async write(key, data) {
        this.data[key] = data;
    }
    async read(key) {
        return this.data[key];
    }
    async remove(key) {
        delete this.data[key];
    }
    storageKey(key) {
        return `mock-${key}`;
    }
}

class MockUserInterface extends session$1.AbstractUserInterface {
    constructor() {
        super(...arguments);
        this.logging = false;
        this.messages = [];
        this.localeDefinitions = {};
    }
    log(message) {
        this.messages.push(message);
        if (this.logging) {
            console.info('MockUserInterface', message);
        }
    }
    async login(context) {
        let chainId = context.chain?.id;
        if (!chainId) {
            chainId = session$1.Checksum256.from(context.chains[0].id);
        }
        let permissionLevel = context.permissionLevel;
        if (!permissionLevel) {
            permissionLevel = session$1.PermissionLevel.from('mock@interface');
        }
        return {
            chainId,
            permissionLevel,
            walletPluginIndex: 0,
        };
    }
    async onError(error) {
        this.log('onError: ' + JSON.stringify(error));
    }
    async onLogin(options) {
        this.log('onLogin: ' + JSON.stringify(options));
    }
    async onLoginComplete() {
        this.log('onLoginComplete');
    }
    async onTransact() {
        this.log('onTransact');
    }
    async onTransactComplete() {
        this.log('onTransactComplete');
    }
    async onSign() {
        this.log('onSign');
    }
    async onSignComplete() {
        this.log('onSignComplete');
    }
    async onBroadcast() {
        this.log('onBroadcast');
    }
    async onBroadcastComplete() {
        this.log('onBroadcastComplete');
    }
    prompt(args) {
        this.log('prompt' + JSON.stringify(args));
        return session$1.cancelable(new Promise(() => {
        }), (canceled) => {
            throw canceled;
        });
    }
    status(message) {
        this.log(`status:('${message}')`);
    }
    addTranslations(definitions) {
        this.log('addTranslations: ' + JSON.stringify(definitions));
    }
    async onAccountCreate() {
        this.log('onAccountCreate');
        return Promise.resolve({});
    }
    async onAccountCreateComplete() {
        this.log('onAccountCreateComplete');
    }
}

const wallet = makeWallet();
const mockSessionKitArgs = {
    appName: 'unittest',
    chains: mockChainDefinitions,
    ui: new MockUserInterface(),
    walletPlugins: [wallet],
};
const mockSessionKitOptions = {
    fetch: mockFetch,
    storage: new MockStorage(),
};
const mockSessionKit = new session$1.SessionKit(mockSessionKitArgs, mockSessionKitOptions);
const mockSessionArgs = {
    chain: mockChainDefinition,
    permissionLevel: antelope.PermissionLevel.from(mockPermissionLevel),
    walletPlugin: wallet,
};
const mockSessionOptions = {
    broadcast: false,
    fetch: mockFetch,
};
const mockSession = new session$1.Session(mockSessionArgs, mockSessionOptions);

const client$1 = new antelope.APIClient({
    provider: new antelope.FetchProvider(mockUrl, { fetch: mockFetch }),
});
const session = new session$1.Session(mockSessionArgs, mockSessionOptions);
const abiCache = new session$1.ABICache(client$1);
const mockTransactContextOptions = {
    abiCache,
    chain: session$1.ChainDefinition.from(mockChainDefinition),
    client: client$1,
    createRequest: async (args) => session.createRequest(args, abiCache),
    fetch: mockFetch,
    permissionLevel: antelope.PermissionLevel.from('wharfkit1125@test'),
};
function makeContext() {
    return new session$1.TransactContext(mockTransactContextOptions);
}

const client = makeClient();
async function mockData(memo) {
    const info = await client.v1.chain.get_info();
    const action = await makeMockAction(memo);
    const actions = await makeMockActions(memo);
    const transaction = await makeMockTransaction(info, memo);
    const session = new session$1.Session(mockSessionArgs, mockSessionOptions);
    return {
        action,
        actions,
        info,
        session,
        transaction,
    };
}

async function mockLoginHook() {
}
async function mockTransactHook(request) {
    return {
        request,
        signatures: [],
    };
}
class MockTransactPlugin extends session$1.AbstractTransactPlugin {
    constructor() {
        super(...arguments);
        this.id = 'mock-transact-plugin';
    }
    register(context) {
        context.addHook(session$1.TransactHookTypes.beforeSign, mockTransactHook);
        context.addHook(session$1.TransactHookTypes.afterSign, mockTransactHook);
        context.addHook(session$1.TransactHookTypes.afterBroadcast, mockTransactHook);
    }
}
class noop extends session$1.Struct {
}
noop.abiName = 'noop';
noop.abiFields = [];
async function mockTransactResourceProviderPresignHook(request, context) {
    const options = context.transactPluginsOptions;
    if (options.disableExamplePlugin) {
        return {
            request,
            signatures: [],
        };
    }
    const newAction = session$1.Action.from({
        account: 'greymassnoop',
        name: 'noop',
        authorization: [
            {
                actor: 'greymassfuel',
                permission: 'cosign',
            },
        ],
        data: noop.from({}),
    });
    const modified = session$1.prependAction(request, newAction);
    return {
        request: modified,
        signatures: [],
    };
}
class MockTransactResourceProviderPlugin extends session$1.AbstractTransactPlugin {
    constructor() {
        super(...arguments);
        this.id = 'mock-transact-resource-provider-plugin';
    }
    register(context) {
        context.addHook(session$1.TransactHookTypes.beforeSign, mockTransactResourceProviderPresignHook);
    }
}
const mockTransactActionPrependerPlugin = {
    id: 'mock-transact-action-prepender-plugin',
    register: (context) => context.addHook(session$1.TransactHookTypes.beforeSign, async (request, context) => ({
        request: await session$1.SigningRequest.create({
            actions: [
                {
                    account: 'greymassnoop',
                    name: 'noop',
                    authorization: [
                        {
                            actor: [...Array(12)]
                                .map(() => Math.random().toString(36)[2])
                                .join(''),
                            permission: 'test',
                        },
                    ],
                    data: {},
                },
                ...request.getRawActions(),
            ],
        }, context.esrOptions),
    })),
};
const mockMetadataFooWriterPlugin = {
    id: 'mock-metadata-foo-writer-plugin',
    register: (context) => context.addHook(session$1.TransactHookTypes.beforeSign, async (request) => {
        request.setInfoKey('foo', 'baz');
        return {
            request,
        };
    }),
};

exports.MockStorage = MockStorage;
exports.MockTransactPlugin = MockTransactPlugin;
exports.MockTransactResourceProviderPlugin = MockTransactResourceProviderPlugin;
exports.MockUserInterface = MockUserInterface;
exports.MockWalletPluginConfigs = MockWalletPluginConfigs;
exports.makeClient = makeClient;
exports.makeContext = makeContext;
exports.makeMockAction = makeMockAction;
exports.makeMockActions = makeMockActions;
exports.makeMockTransaction = makeMockTransaction;
exports.makeWallet = makeWallet;
exports.mockAccountName = mockAccountName;
exports.mockChainDefinition = mockChainDefinition;
exports.mockChainDefinitions = mockChainDefinitions;
exports.mockChainId = mockChainId;
exports.mockData = mockData;
exports.mockFetch = mockFetch;
exports.mockLoginHook = mockLoginHook;
exports.mockMetadataFooWriterPlugin = mockMetadataFooWriterPlugin;
exports.mockPermissionLevel = mockPermissionLevel;
exports.mockPermissionName = mockPermissionName;
exports.mockPrivateKey = mockPrivateKey;
exports.mockSession = mockSession;
exports.mockSessionArgs = mockSessionArgs;
exports.mockSessionKit = mockSessionKit;
exports.mockSessionKitArgs = mockSessionKitArgs;
exports.mockSessionKitOptions = mockSessionKitOptions;
exports.mockSessionOptions = mockSessionOptions;
exports.mockTransactActionPrependerPlugin = mockTransactActionPrependerPlugin;
exports.mockTransactContextOptions = mockTransactContextOptions;
exports.mockTransactHook = mockTransactHook;
exports.mockTransactResourceProviderPresignHook = mockTransactResourceProviderPresignHook;
exports.mockUrl = mockUrl;
//# sourceMappingURL=mock-data.js.map
